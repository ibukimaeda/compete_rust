{
  ":Xorshift": {
    "scope": "rust",
    "prefix": ":Xorshift",
    "body": [
      "#[derive(Debug)]",
      "#[allow(dead_code)]",
      "pub struct Xorshift {",
      "    seed: u64,",
      "}",
      "impl Xorshift {",
      "    #[allow(dead_code)]",
      "    pub fn new() -> Xorshift {",
      "        Xorshift {",
      "            seed: 0xf0fb588ca2196dac,",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    pub fn with_seed(seed: u64) -> Xorshift {",
      "        Xorshift { seed: seed }",
      "    }",
      "    #[inline]",
      "    #[allow(dead_code)]",
      "    pub fn next(&mut self) -> u64 {",
      "        self.seed = self.seed ^ (self.seed << 13);",
      "        self.seed = self.seed ^ (self.seed >> 7);",
      "        self.seed = self.seed ^ (self.seed << 17);",
      "        self.seed",
      "    }",
      "    #[inline]",
      "    #[allow(dead_code)]",
      "    pub fn rand(&mut self, m: u64) -> u64 {",
      "        self.next() % m",
      "    }",
      "    #[inline]",
      "    #[allow(dead_code)]",
      "    pub fn rand_range(&mut self, l: u64, r: u64) -> u64 {",
      "        self.rand(r - l) + l",
      "    }",
      "    #[inline]",
      "    #[allow(dead_code)]",
      "    pub fn randf(&mut self) -> f64 {",
      "        use std::mem;",
      "        const UPPER_MASK: u64 = 0x3FF0000000000000;",
      "        const LOWER_MASK: u64 = 0xFFFFFFFFFFFFF;",
      "        let tmp = UPPER_MASK | (self.next() & LOWER_MASK);",
      "        let result: f64 = unsafe { mem::transmute(tmp) };",
      "        result - 1.0",
      "    }",
      "}"
    ]
  },
  ":comb": {
    "scope": "rust",
    "prefix": ":comb",
    "body": [
      "struct CombUtil<Int>",
      "where",
      "    Int: PrimInt,",
      "{",
      "    fc: Vec<Int>,",
      "    ifc: Vec<Int>,",
      "    mod_value: Int,",
      "}",
      "impl<Int> CombUtil<Int>",
      "where",
      "    Int: PrimInt + Default,",
      "{",
      "    #[allow(dead_code)]",
      "    fn new(size: usize, mod_value: Int) -> Self {",
      "        let mut fc = vec![Int::default(); size + 1];",
      "        let mut ifc = vec![Int::default(); size + 1];",
      "        fc[0] = Int::from(1).unwrap();",
      "        for i in 1..=size {",
      "            fc[i] = fc[i - 1] * Int::from(i).unwrap() % mod_value;",
      "        }",
      "        ifc[size] = Self::inv(fc[size], mod_value);",
      "        for i in (0..size).rev() {",
      "            ifc[i] = ifc[i + 1] * Int::from(i + 1).unwrap() % mod_value;",
      "        }",
      "        Self { fc, ifc, mod_value }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn fact(&self, n: usize) -> Int {",
      "        self.fc[n]",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv_fact(&self, n: usize) -> Int {",
      "        self.ifc[n]",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv(n: Int, mod_value: Int) -> Int {",
      "        Self::pow(n, mod_value - Int::from(2).unwrap(), mod_value)",
      "    }",
      "    #[allow(dead_code)]",
      "    fn pow(n: Int, mut a: Int, mod_value: Int) -> Int {",
      "        let mut res = Int::from(1).unwrap();",
      "        let mut exp = n % mod_value;",
      "        while a > Int::from(0).unwrap() {",
      "            if a % Int::from(2).unwrap() == Int::from(1).unwrap() {",
      "                res = res * exp % mod_value;",
      "            }",
      "            exp = exp * exp % mod_value;",
      "            a = a / Int::from(2).unwrap();",
      "        }",
      "        res",
      "    }",
      "    #[allow(dead_code)]",
      "    fn npr(&self, n: usize, r: usize) -> Int {",
      "        if r > n {",
      "            Int::from(0).unwrap()",
      "        } else {",
      "            self.fc[n] * self.ifc[n - r] % self.mod_value",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn ncr(&self, n: i64, r: i64) -> Int {",
      "        if n < 0 || r < 0 || n < r {",
      "            Int::from(0).unwrap()",
      "        } else {",
      "            self.fc[n as usize] * self.ifc[r as usize] % self.mod_value * self.ifc[(n - r) as usize]",
      "                % self.mod_value",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn homo(&self, n: i64, r: i64) -> Int {",
      "        if r == 0 {",
      "            Int::from(1).unwrap()",
      "        } else if n < 0 || r < 0 {",
      "            Int::from(0).unwrap()",
      "        } else {",
      "            self.ncr(n + r - 1, r)",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "type Comb = CombUtil<i64>;"
    ]
  },
  ":dijkstra": {
    "scope": "rust",
    "prefix": ":dijkstra",
    "body": [
      "#[allow(dead_code)]",
      "fn dijkstra(graph: &Vec<Vec<(usize, i64)>>, start: usize) -> Vec<i64> {",
      "    let mut dist = vec![INF; graph.len()];",
      "    let mut heap = BinaryHeap::new();",
      "    dist[start] = 0;",
      "    heap.push((Reverse(0), start));",
      "    while let Some((Reverse(cost), position)) = heap.pop() {",
      "        if cost > dist[position] {",
      "            continue;",
      "        }",
      "        for &(to, to_cost) in &graph[position] {",
      "            let next_cost = cost + to_cost;",
      "            if next_cost < dist[to] {",
      "                heap.push((Reverse(next_cost), to));",
      "                dist[to] = next_cost;",
      "            }",
      "        }",
      "    }",
      "    return dist;",
      "}"
    ]
  },
  ":extgcd": {
    "scope": "rust",
    "prefix": ":extgcd",
    "body": [
      "#[allow(dead_code)]",
      "fn extgcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    fn _extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {",
      "        let mut g = a;",
      "        *x = 1;",
      "        *y = 0;",
      "        if b != 0 {",
      "            g = _extgcd(b, a % b, y, x);",
      "            *y -= (a / b) * *x;",
      "        }",
      "        g",
      "    }",
      "    let mut x = 0;",
      "    let mut y = 0;",
      "    let g = _extgcd(a, b, &mut x, &mut y);",
      "    (x, y, g)",
      "}",
      "#[allow(dead_code)]",
      "fn positive_extgcd(a: i64, b: i64) -> Option<(i64, i64, i64)> {",
      "    let (x, y, g) = extgcd(a, b);",
      "    let (a_g, b_g) = (a / g, b / g);",
      "    let r = x % b_g;",
      "    let px = if r >= 0 { r } else { r + b_g };",
      "    let py = y + (x - px) / b_g * a_g;",
      "    if py >= 0 {",
      "        Some((px, py, g))",
      "    } else {",
      "        None",
      "    }",
      "}"
    ]
  },
  ":grid_astar": {
    "scope": "rust",
    "prefix": ":grid_astar",
    "body": [
      "#[allow(dead_code)]",
      "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
      "struct Point {",
      "    row: usize,",
      "    col: usize,",
      "}",
      "#[allow(dead_code)]",
      "#[derive(Debug, PartialEq, Eq)]",
      "struct AstarNode {",
      "    cost: usize,",
      "    position: Point,",
      "    priority: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl Ord for AstarNode {",
      "    fn cmp(&self, other: &Self) -> Ordering {",
      "        other.priority.cmp(&self.priority)",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "impl PartialOrd for AstarNode {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        Some(self.cmp(other))",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "struct AStar {",
      "    grid: Vec<Vec<u8>>,",
      "}",
      "#[allow(dead_code)]",
      "impl AStar {",
      "    fn new(grid: Vec<Vec<u8>>) -> Self {",
      "        AStar { grid }",
      "    }",
      "    fn heuristic(a: Point, b: Point) -> usize {",
      "        (a.row as isize - b.row as isize).abs() as usize",
      "            + (a.col as isize - b.col as isize).abs() as usize",
      "    }",
      "    fn find_path(&self, start: Point, goal: Point) -> Option<Vec<Point>> {",
      "        let mut open_set = BinaryHeap::new();",
      "        let mut came_from: FxHashMap<Point, Point> = FxHashMap::default();",
      "        let mut g_score: FxHashMap<Point, usize> = FxHashMap::default();",
      "        g_score.insert(start, 0);",
      "        open_set.push(AstarNode {",
      "            cost: 0,",
      "            position: start,",
      "            priority: Self::heuristic(start, goal),",
      "        });",
      "        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];",
      "        while let Some(AstarNode { position, .. }) = open_set.pop() {",
      "            if position == goal {",
      "                let mut path = vec![position];",
      "                while let Some(&prev) = came_from.get(&path[0]) {",
      "                    path.insert(0, prev);",
      "                }",
      "                return Some(path);",
      "            }",
      "            let current_cost = *g_score.get(&position).unwrap_or(&usize::MAX);",
      "            for (dx, dy) in directions.iter() {",
      "                let new_x = position.row as isize + dx;",
      "                let new_y = position.col as isize + dy;",
      "                if new_x < 0 || new_y < 0 {",
      "                    continue;",
      "                }",
      "                let new_x = new_x as usize;",
      "                let new_y = new_y as usize;",
      "                if new_x >= self.grid.len()",
      "                    || new_y >= self.grid[0].len()",
      "                    || self.grid[new_x][new_y] == 1",
      "                {",
      "                    continue;",
      "                }",
      "                let new_pos = Point {",
      "                    row: new_x,",
      "                    col: new_y,",
      "                };",
      "                let tentative_g_score = current_cost + 1;",
      "                if tentative_g_score < *g_score.get(&new_pos).unwrap_or(&usize::MAX) {",
      "                    came_from.insert(new_pos, position);",
      "                    g_score.insert(new_pos, tentative_g_score);",
      "                    let priority = tentative_g_score + Self::heuristic(new_pos, goal);",
      "                    open_set.push(AstarNode {",
      "                        cost: tentative_g_score,",
      "                        position: new_pos,",
      "                        priority,",
      "                    });",
      "                }",
      "            }",
      "        }",
      "        None",
      "    }",
      "}"
    ]
  },
  ":interval_heap": {
    "scope": "rust",
    "prefix": ":interval_heap",
    "body": [
      "#[derive(Clone, Debug)]",
      "struct IntervalHeap<T: Ord + Eq> {",
      "    data: Vec<T>,",
      "}",
      "impl<T: Ord + Eq> IntervalHeap<T> {",
      "    #[allow(dead_code)]",
      "    fn new() -> IntervalHeap<T> {",
      "        IntervalHeap { data: Vec::new() }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn with_capacity(n: usize) -> IntervalHeap<T> {",
      "        IntervalHeap {",
      "            data: Vec::with_capacity(n),",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn len(&self) -> usize {",
      "        self.data.len()",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn is_empty(&self) -> bool {",
      "        self.data.is_empty()",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn push(&mut self, x: T) {",
      "        let i = self.data.len();",
      "        self.data.push(x);",
      "        self.up(i);",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn peek_min(&self) -> Option<&T> {",
      "        self.data.first()",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn peek_max(&self) -> Option<&T> {",
      "        if self.data.len() > 1 {",
      "            self.data.get(1)",
      "        } else {",
      "            self.data.first()",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn pop_min(&mut self) -> Option<T> {",
      "        if self.data.len() == 1 {",
      "            return self.data.pop();",
      "        }",
      "        if self.data.is_empty() {",
      "            return None;",
      "        }",
      "        let len = self.data.len();",
      "        self.data.swap(0, len - 1);",
      "        let res = self.data.pop();",
      "        self.down(0);",
      "        res",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn pop_max(&mut self) -> Option<T> {",
      "        if self.data.len() <= 2 {",
      "            return self.data.pop();",
      "        }",
      "        if self.data.is_empty() {",
      "            return None;",
      "        }",
      "        let len = self.data.len();",
      "        self.data.swap(1, len - 1);",
      "        let res = self.data.pop();",
      "        self.down(1);",
      "        res",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn parent(i: usize) -> usize {",
      "        ((i >> 1) - 1) & !1",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn down(&mut self, i: usize) {",
      "        let mut i = i;",
      "        let n = self.data.len();",
      "        if i & 1 == 0 {",
      "            while (i << 1) + 2 < n {",
      "                let mut k = (i << 1) + 2;",
      "                if k + 2 < n",
      "                    && unsafe { self.data.get_unchecked(k + 2) }",
      "                        < unsafe { self.data.get_unchecked(k) }",
      "                {",
      "                    k = k + 2;",
      "                }",
      "                if unsafe { self.data.get_unchecked(i) } > unsafe { self.data.get_unchecked(k) } {",
      "                    self.data.swap(i, k);",
      "                    i = k;",
      "                    if i + 1 < self.data.len()",
      "                        && unsafe { self.data.get_unchecked(i) }",
      "                            > unsafe { self.data.get_unchecked(i + 1) }",
      "                    {",
      "                        self.data.swap(i, i + 1);",
      "                    }",
      "                } else {",
      "                    break;",
      "                }",
      "            }",
      "        } else {",
      "            while (i << 1) + 1 < n {",
      "                let mut k = (i << 1) + 1;",
      "                if k + 2 < n",
      "                    && unsafe { self.data.get_unchecked(k + 2) }",
      "                        > unsafe { self.data.get_unchecked(k) }",
      "                {",
      "                    k = k + 2;",
      "                }",
      "                if unsafe { self.data.get_unchecked(i) } < unsafe { self.data.get_unchecked(k) } {",
      "                    self.data.swap(i, k);",
      "                    i = k;",
      "                    if i > 0",
      "                        && unsafe { self.data.get_unchecked(i) }",
      "                            < unsafe { self.data.get_unchecked(i - 1) }",
      "                    {",
      "                        self.data.swap(i, i - 1);",
      "                    }",
      "                } else {",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn up(&mut self, i: usize) {",
      "        let mut i = i;",
      "        if i & 1 == 1",
      "            && unsafe { self.data.get_unchecked(i) } < unsafe { self.data.get_unchecked(i - 1) }",
      "        {",
      "            self.data.swap(i, i - 1);",
      "            i -= 1;",
      "        }",
      "        while i > 1",
      "            && unsafe { self.data.get_unchecked(i) }",
      "                < unsafe { self.data.get_unchecked(Self::parent(i)) }",
      "        {",
      "            let p = Self::parent(i);",
      "            self.data.swap(i, p);",
      "            i = p;",
      "        }",
      "        while i > 1",
      "            && unsafe { self.data.get_unchecked(i) }",
      "                > unsafe { self.data.get_unchecked(Self::parent(i) + 1) }",
      "        {",
      "            let p = Self::parent(i) + 1;",
      "            self.data.swap(i, p);",
      "            i = p;",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn clear(&mut self) {",
      "        self.data.clear();",
      "    }",
      "}",
      "#[derive(Clone, Debug)]",
      "struct LimitedIntervalHeap<T: Ord + Eq> {",
      "    heap: IntervalHeap<T>,",
      "    limit: usize,",
      "}",
      "impl<T: Ord + Eq> LimitedIntervalHeap<T> {",
      "    #[allow(dead_code)]",
      "    fn new(limit: usize) -> LimitedIntervalHeap<T> {",
      "        LimitedIntervalHeap {",
      "            heap: IntervalHeap::with_capacity(limit),",
      "            limit: limit,",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn is_empty(&self) -> bool {",
      "        self.heap.is_empty()",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn push(&mut self, x: T) -> Option<T> {",
      "        if self.heap.len() < self.limit {",
      "            self.heap.push(x);",
      "            None",
      "        } else {",
      "            if self.heap.data[0] < x {",
      "                let mut x = x;",
      "                std::mem::swap(&mut x, &mut self.heap.data[0]);",
      "                if self.heap.len() >= 2 && self.heap.data[0] > self.heap.data[1] {",
      "                    self.heap.data.swap(0, 1);",
      "                }",
      "                self.heap.down(0);",
      "                Some(x)",
      "            } else {",
      "                Some(x)",
      "            }",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn pop(&mut self) -> Option<T> {",
      "        self.heap.pop_max()",
      "    }",
      "    #[allow(dead_code)]",
      "    #[inline]",
      "    fn clear(&mut self) {",
      "        self.heap.clear();",
      "    }",
      "}"
    ]
  },
  ":lazy_segment_tree": {
    "scope": "rust",
    "prefix": ":lazy_segment_tree",
    "body": [
      "impl<S, F, E, T, G, H, I> LazySegmentTree<S, F, E, T, G, H, I>",
      "where",
      "    S: Copy + Eq,",
      "    T: Copy + Eq,",
      "    F: Fn(S, S) -> S,",
      "    E: Fn() -> S,",
      "    G: Fn(T, S) -> S,",
      "    H: Fn() -> T,",
      "    I: Fn(T, T) -> T,",
      "{",
      "    pub fn new(init_value: Vec<S>, op: F, element: E, mapping: G, id: H, composite: I) -> Self {",
      "        let n = init_value.len().next_power_of_two();",
      "        let tree_size = 2 * n - 1;",
      "        let mut value = vec![element(); tree_size];",
      "        let lazy = vec![id(); tree_size];",
      "        for i in 0..init_value.len() {",
      "            value[i + n - 1] = init_value[i];",
      "        }",
      "        for i in (0..n - 1).rev() {",
      "            value[i] = (op)(value[i * 2 + 1], value[i * 2 + 2]);",
      "        }",
      "        Self {",
      "            value,",
      "            op,",
      "            element,",
      "            lazy,",
      "            mapping,",
      "            id,",
      "            composite,",
      "        }",
      "    }",
      "    pub fn apply(&mut self, v: T, left: usize, right: usize) {",
      "        self._apply(v, left, right, 0, 0, self.value.len() / 2 + 1);",
      "    }",
      "    pub fn prod(&mut self, left: usize, right: usize) -> S {",
      "        assert!(left <= right);",
      "        if right == left {",
      "            (self.element)()",
      "        } else {",
      "            self._prod(left, right, 0, 0, self.value.len() / 2 + 1)",
      "        }",
      "    }",
      "    pub fn eval_all(&mut self) {",
      "        self._eval_all(0, 0, self.value.len() / 2 + 1);",
      "    }",
      "    pub fn get(&mut self, index: usize) -> S {",
      "        self.prod(index, index + 1)",
      "    }",
      "    fn _eval(&mut self, tree_index: usize, left: usize, right: usize) {",
      "        if self.lazy[tree_index] == (self.id)() {",
      "            return;",
      "        }",
      "        self.value[tree_index] = (self.mapping)(self.lazy[tree_index], self.value[tree_index]);",
      "        if right - left > 1 {",
      "            let (left_t_index, right_t_index) = self._get_children(tree_index);",
      "            self.lazy[left_t_index] =",
      "                (self.composite)(self.lazy[tree_index], self.lazy[left_t_index]);",
      "            self.lazy[right_t_index] =",
      "                (self.composite)(self.lazy[tree_index], self.lazy[right_t_index]);",
      "        }",
      "        self.lazy[tree_index] = (self.id)();",
      "    }",
      "    fn _eval_all(&mut self, k: usize, l: usize, r: usize) {",
      "        self._eval(k, l, r);",
      "        if r - l > 1 {",
      "            let mid = (l + r) / 2;",
      "            let (left_t_index, right_t_index) = self._get_children(k);",
      "            self._eval_all(left_t_index, l, mid);",
      "            self._eval_all(right_t_index, mid, r);",
      "        }",
      "    }",
      "    fn _apply(",
      "        &mut self,",
      "        v: T,",
      "        search_left: usize,",
      "        search_right: usize,",
      "        tree_index: usize,",
      "        left: usize,",
      "        right: usize,",
      "    ) {",
      "        assert!(search_left <= search_right);",
      "        assert!(left <= right);",
      "        self._eval(tree_index, left, right);",
      "        if right <= search_left || search_right <= left {",
      "            return;",
      "        }",
      "        if search_left <= left && right <= search_right {",
      "            self.lazy[tree_index] = (self.composite)(v, self.lazy[tree_index]);",
      "            self._eval(tree_index, left, right);",
      "        } else {",
      "            let mid = (left + right) / 2;",
      "            let (left_t_index, right_t_index) = self._get_children(tree_index);",
      "            self._apply(v, search_left, search_right, left_t_index, left, mid);",
      "            self._apply(v, search_left, search_right, right_t_index, mid, right);",
      "            self.value[tree_index] = (self.op)(self.value[left_t_index], self.value[right_t_index]);",
      "        }",
      "    }",
      "    #[inline(always)]",
      "    fn _get_children(&self, tree_index: usize) -> (usize, usize) {",
      "        (tree_index * 2 + 1, tree_index * 2 + 2)",
      "    }",
      "    fn _prod(",
      "        &mut self,",
      "        search_left: usize,",
      "        search_right: usize,",
      "        tree_index: usize,",
      "        left: usize,",
      "        right: usize,",
      "    ) -> S {",
      "        assert!(search_left <= search_right);",
      "        assert!(left <= right);",
      "        if search_right <= left || right <= search_left {",
      "            return (self.element)();",
      "        }",
      "        self._eval(tree_index, left, right);",
      "        if search_left <= left && right <= search_right {",
      "            self.value[tree_index]",
      "        } else {",
      "            let mid = (left + right) / 2;",
      "            let (left_t_index, right_t_index) = self._get_children(tree_index);",
      "            let l_value = self._prod(search_left, search_right, left_t_index, left, mid);",
      "            let r_value = self._prod(search_left, search_right, right_t_index, mid, right);",
      "            (self.op)(l_value, r_value)",
      "        }",
      "    }",
      "}",
      "type RangeAddMinSegTree = LazySegmentTree<",
      "    i64,",
      "    fn(i64, i64) -> i64,",
      "    fn() -> i64,",
      "    i64,",
      "    fn(i64, i64) -> i64,",
      "    fn() -> i64,",
      "    fn(i64, i64) -> i64,",
      ">;",
      "impl RangeAddMinSegTree {",
      "    pub fn range_add_min(init_value: Vec<i64>) -> Self {",
      "        let op = |x: i64, y: i64| std::cmp::min(x, y);",
      "        let element = || 1_010_000_000_000_000_017;",
      "        let mapping = |f: i64, x: i64| f + x;",
      "        let id = || 0i64;",
      "        let composite = |f: i64, g: i64| f + g;",
      "        LazySegmentTree::new(init_value, op, element, mapping, id, composite)",
      "    }",
      "}",
      "type RangeAddMaxSegTree = LazySegmentTree<",
      "    i64,",
      "    fn(i64, i64) -> i64,",
      "    fn() -> i64,",
      "    i64,",
      "    fn(i64, i64) -> i64,",
      "    fn() -> i64,",
      "    fn(i64, i64) -> i64,",
      ">;",
      "impl RangeAddMaxSegTree {",
      "    pub fn range_add_max(init_value: Vec<i64>) -> Self {",
      "        let op = |x: i64, y: i64| std::cmp::max(x, y);",
      "        let element = || -1_010_000_000_000_000_017;",
      "        let mapping = |f: i64, x: i64| f + x;",
      "        let id = || 0i64;",
      "        let composite = |f: i64, g: i64| f + g;",
      "        LazySegmentTree::new(init_value, op, element, mapping, id, composite)",
      "    }",
      "}",
      "#[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "struct RangeSum {",
      "    sum: i64,",
      "    count: i64,",
      "}",
      "type RangeAddSumSegTree = LazySegmentTree<",
      "    RangeSum,",
      "    fn(RangeSum, RangeSum) -> RangeSum,",
      "    fn() -> RangeSum,",
      "    i64,",
      "    fn(i64, RangeSum) -> RangeSum,",
      "    fn() -> i64,",
      "    fn(i64, i64) -> i64,",
      ">;",
      "impl RangeAddSumSegTree {",
      "    pub fn range_add_sum(init_value: Vec<i64>) -> Self {",
      "        let op = |a: RangeSum, b: RangeSum| RangeSum {",
      "            sum: a.sum + b.sum,",
      "            count: a.count + b.count,",
      "        };",
      "        let element = || RangeSum { sum: 0, count: 0 };",
      "        let mapping = |f: i64, x: RangeSum| RangeSum {",
      "            sum: f * x.count + x.sum,",
      "            count: x.count,",
      "        };",
      "        let id = || 0i64;",
      "        let composite = |f: i64, g: i64| f + g;",
      "        let init_value = init_value",
      "            .iter()",
      "            .map(|&x| RangeSum { sum: x, count: 1 })",
      "            .collect();",
      "        LazySegmentTree::new(init_value, op, element, mapping, id, composite)",
      "    }",
      "}",
      "type RangeUpdateMinSegTree = LazySegmentTree<",
      "    i64,",
      "    fn(i64, i64) -> i64,",
      "    fn() -> i64,",
      "    Option<i64>,",
      "    fn(Option<i64>, i64) -> i64,",
      "    fn() -> Option<i64>,",
      "    fn(Option<i64>, Option<i64>) -> Option<i64>,",
      ">;",
      "impl RangeUpdateMinSegTree {",
      "    pub fn range_update_min(init_value: Vec<i64>) -> Self {",
      "        let op = |x: i64, y: i64| std::cmp::min(x, y);",
      "        let element = || 1_010_000_000_000_000_017;",
      "        let mapping = |f: Option<i64>, x: i64| match f {",
      "            Some(val) => val,",
      "            None => x,",
      "        };",
      "        let id = || None::<i64>;",
      "        let composite = |f: Option<i64>, g: Option<i64>| match f {",
      "            Some(_) => f,",
      "            None => g,",
      "        };",
      "        LazySegmentTree::new(init_value, op, element, mapping, id, composite)",
      "    }",
      "}",
      "type RangeUpdateMaxSegTree = LazySegmentTree<",
      "    i64,",
      "    fn(i64, i64) -> i64,",
      "    fn() -> i64,",
      "    Option<i64>,",
      "    fn(Option<i64>, i64) -> i64,",
      "    fn() -> Option<i64>,",
      "    fn(Option<i64>, Option<i64>) -> Option<i64>,",
      ">;",
      "impl RangeUpdateMaxSegTree {",
      "    pub fn range_update_max(init_value: Vec<i64>) -> Self {",
      "        let op = |x: i64, y: i64| std::cmp::max(x, y);",
      "        let element = || -1_010_000_000_000_000_017;",
      "        let mapping = |f: Option<i64>, x: i64| match f {",
      "            Some(val) => val,",
      "            None => x,",
      "        };",
      "        let id = || None::<i64>;",
      "        let composite = |f: Option<i64>, g: Option<i64>| match f {",
      "            Some(_) => f,",
      "            None => g,",
      "        };",
      "        LazySegmentTree::new(init_value, op, element, mapping, id, composite)",
      "    }",
      "}",
      "type RangeUpdateSumSegTree = LazySegmentTree<",
      "    RangeSum,",
      "    fn(RangeSum, RangeSum) -> RangeSum,",
      "    fn() -> RangeSum,",
      "    Option<i64>,",
      "    fn(Option<i64>, RangeSum) -> RangeSum,",
      "    fn() -> Option<i64>,",
      "    fn(Option<i64>, Option<i64>) -> Option<i64>,",
      ">;",
      "impl RangeUpdateSumSegTree {",
      "    pub fn range_update_sum(init_value: Vec<i64>) -> Self {",
      "        let op = |x: RangeSum, y: RangeSum| RangeSum {",
      "            sum: x.sum + y.sum,",
      "            count: x.count + y.count,",
      "        };",
      "        let element = || RangeSum { sum: 0, count: 0 };",
      "        let mapping = |f: Option<i64>, x: RangeSum| RangeSum {",
      "            sum: match f {",
      "                Some(val) => val * x.count,",
      "                None => x.sum,",
      "            },",
      "            count: x.count,",
      "        };",
      "        let id = || None::<i64>;",
      "        let composite = |f: Option<i64>, g: Option<i64>| f.or(g);",
      "        let init_value = init_value",
      "            .iter()",
      "            .map(|&x| RangeSum { sum: x, count: 1 })",
      "            .collect();",
      "        LazySegmentTree::new(init_value, op, element, mapping, id, composite)",
      "    }",
      "}"
    ]
  },
  ":mod_int": {
    "scope": "rust",
    "prefix": ":mod_int",
    "body": [
      "#[derive(Clone, Copy, Debug)]",
      "struct ModInt {",
      "    x: i64,",
      "    modulo: i64,",
      "}",
      "impl ModInt {",
      "    #[allow(dead_code)]",
      "    fn new(x: i64, modulo: i64) -> Self {",
      "        let x = if x >= 0 {",
      "            x % modulo",
      "        } else {",
      "            (modulo - (-x) % modulo) % modulo",
      "        };",
      "        ModInt { x, modulo }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn set(&mut self, x: i64) {",
      "        if x >= 0 {",
      "            self.x = x % self.modulo",
      "        } else {",
      "            self.x = (self.modulo - (-x) % self.modulo) % self.modulo",
      "        };",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv(&self) -> Self {",
      "        let mut a = self.x;",
      "        let mut b = self.modulo;",
      "        let mut u: i64 = 1;",
      "        let mut v: i64 = 0;",
      "        while b > 0 {",
      "            let t = a / b;",
      "            a -= t * b;",
      "            mem::swap(&mut a, &mut b);",
      "            u -= t * v;",
      "            mem::swap(&mut u, &mut v);",
      "        }",
      "        u %= self.modulo;",
      "        if u < 0 {",
      "            u += self.modulo;",
      "        }",
      "        return ModInt {",
      "            x: u,",
      "            modulo: self.modulo,",
      "        };",
      "    }",
      "    #[allow(dead_code)]",
      "    fn pow(&self, mut n: i64) -> Self {",
      "        let mut a = self.x;",
      "        let mut res: i64 = 1;",
      "        while n > 0 {",
      "            if n & 1 == 1 {",
      "                res = (res * a) % self.modulo;",
      "            }",
      "            a = (a * a) % self.modulo;",
      "            n >>= 1;",
      "        }",
      "        return ModInt {",
      "            x: res,",
      "            modulo: self.modulo,",
      "        };",
      "    }",
      "}",
      "impl fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "        write!(f, \"{}\", self.x)",
      "    }",
      "}",
      "impl ops::Neg for ModInt {",
      "    type Output = ModInt;",
      "    fn neg(self) -> Self::Output {",
      "        ModInt::new(-self.x, self.modulo)",
      "    }",
      "}",
      "impl ops::Add<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: Self) -> Self::Output {",
      "        return ModInt::new(self.x + rhs.x, self.modulo);",
      "    }",
      "}",
      "impl ops::Add<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: i64) -> Self::Output {",
      "        return ModInt::new(self.x + rhs, self.modulo);",
      "    }",
      "}",
      "impl<'a> ops::AddAssign<&'a Self> for ModInt {",
      "    fn add_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x + rhs.x);",
      "    }",
      "}",
      "impl ops::AddAssign<i64> for ModInt {",
      "    fn add_assign(&mut self, rhs: i64) {",
      "        self.set(self.x + rhs);",
      "    }",
      "}",
      "impl ops::Sub<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: Self) -> Self::Output {",
      "        return ModInt::new(self.x - rhs.x, self.modulo);",
      "    }",
      "}",
      "impl ops::Sub<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: i64) -> Self::Output {",
      "        return ModInt::new(self.x - rhs, self.modulo);",
      "    }",
      "}",
      "impl<'a> ops::SubAssign<&'a Self> for ModInt {",
      "    fn sub_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x - rhs.x);",
      "    }",
      "}",
      "impl ops::SubAssign<i64> for ModInt {",
      "    fn sub_assign(&mut self, rhs: i64) {",
      "        self.set(self.x - rhs);",
      "    }",
      "}",
      "impl ops::Mul<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: Self) -> Self::Output {",
      "        ModInt::new(self.x * rhs.x, self.modulo)",
      "    }",
      "}",
      "impl ops::Mul<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: i64) -> Self::Output {",
      "        ModInt::new(self.x * rhs, self.modulo)",
      "    }",
      "}",
      "impl<'a> ops::MulAssign<&'a Self> for ModInt {",
      "    fn mul_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x * rhs.x);",
      "    }",
      "}",
      "impl ops::MulAssign<i64> for ModInt {",
      "    fn mul_assign(&mut self, rhs: i64) {",
      "        self.set(self.x * rhs);",
      "    }",
      "}",
      "impl ops::Div<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: Self) -> Self::Output {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl ops::Div<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: i64) -> Self::Output {",
      "        self * ModInt::new(rhs, self.modulo).inv()",
      "    }",
      "}",
      "impl<'a> ops::DivAssign<&'a Self> for ModInt {",
      "    fn div_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x * rhs.inv().x);",
      "    }",
      "}",
      "impl ops::DivAssign<i64> for ModInt {",
      "    fn div_assign(&mut self, rhs: i64) {",
      "        self.set(self.x * ModInt::new(rhs, self.modulo).inv().x);",
      "    }",
      "}",
      "impl cmp::PartialEq<ModInt> for ModInt {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.x == other.x",
      "    }",
      "    fn ne(&self, other: &Self) -> bool {",
      "        self.x != other.x",
      "    }",
      "}",
      "impl cmp::PartialEq<i64> for ModInt {",
      "    fn eq(&self, other: &i64) -> bool {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        self.x == other.x",
      "    }",
      "    fn ne(&self, other: &i64) -> bool {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        self.x != other.x",
      "    }",
      "}",
      "impl cmp::PartialOrd<ModInt> for ModInt {",
      "    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {",
      "        if self.x == other.x {",
      "            Some(cmp::Ordering::Equal)",
      "        } else if self.x > other.x {",
      "            Some(cmp::Ordering::Greater)",
      "        } else {",
      "            Some(cmp::Ordering::Less)",
      "        }",
      "    }",
      "}",
      "impl cmp::PartialOrd<i64> for ModInt {",
      "    fn partial_cmp(&self, other: &i64) -> Option<cmp::Ordering> {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        if self.x == other.x {",
      "            Some(cmp::Ordering::Equal)",
      "        } else if self.x > other.x {",
      "            Some(cmp::Ordering::Greater)",
      "        } else {",
      "            Some(cmp::Ordering::Less)",
      "        }",
      "    }",
      "}"
    ]
  },
  ":rotated": {
    "scope": "rust",
    "prefix": ":rotated",
    "body": [
      "#[allow(dead_code)]",
      "fn rotated<T: Default + Clone>(grid: &Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let mut ret = vec![vec![Default::default(); grid.len()]; grid[0].len()];",
      "    for i in 0..grid[0].len() {",
      "        for j in 0..grid.len() {",
      "            ret[i][j] = grid[grid.len() - 1 - j][i].clone();",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  ":shifted": {
    "scope": "rust",
    "prefix": ":shifted",
    "body": [
      "#[allow(dead_code)]",
      "fn shifted<T: Default + Clone>(grid: &Vec<Vec<T>>, dx: i64, dy: i64, default: T) -> Vec<Vec<T>> {",
      "    let mut ret = vec![vec![Default::default(); grid[0].len()]; grid.len()];",
      "    for i in 0..grid.len() {",
      "        for j in 0..grid[0].len() {",
      "            let mut value = default.clone();",
      "            let nx = i as i64 - dx;",
      "            let ny = j as i64 - dy;",
      "            if 0 <= nx && nx < grid.len() as i64 && 0 <= ny && ny < grid[0].len() as i64 {",
      "                value = grid[nx as usize][ny as usize].clone();",
      "            }",
      "            ret[i][j] = value;",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  ":timer": {
    "scope": "rust",
    "prefix": ":timer",
    "body": [
      "macro_rules! timer {",
      "    (\\$ x : expr ) => {{",
      "        let start = Instant::now();",
      "        let result = \\$x;",
      "        let end = start.elapsed();",
      "        println!(",
      "            \"計測開始から{}.{:03}秒経過しました。\",",
      "            end.as_secs(),",
      "            end.subsec_nanos() / 1_000_000",
      "        );",
      "        result",
      "    }};",
      "}"
    ]
  },
  ":union_find": {
    "scope": "rust",
    "prefix": ":union_find",
    "body": [
      "#[derive(Debug)]",
      "struct UnionFind {",
      "    parent: Vec<i32>,",
      "}",
      "impl UnionFind {",
      "    #[allow(dead_code)]",
      "    fn new(size: usize) -> Self {",
      "        UnionFind {",
      "            parent: vec![-1; size],",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn unite(&mut self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.parent.len());",
      "        assert!(y < self.parent.len());",
      "        let mut x = self.root(x);",
      "        let mut y = self.root(y);",
      "        if x == y {",
      "            return false;",
      "        }",
      "        if self.parent[x] > self.parent[y] {",
      "            mem::swap(&mut x, &mut y);",
      "        }",
      "        self.parent[x] += self.parent[y];",
      "        self.parent[y] = x as i32;",
      "        return true;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn root(&mut self, k: usize) -> usize {",
      "        assert!(k < self.parent.len());",
      "        if self.parent[k as usize] < 0 {",
      "            return k;",
      "        }",
      "        self.parent[k as usize] = self.root(self.parent[k] as usize) as i32;",
      "        return self.parent[k] as usize;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn size(&mut self, k: usize) -> usize {",
      "        assert!(k < self.parent.len());",
      "        let x = self.root(k);",
      "        return -self.parent[x] as usize;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn is_same(&mut self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.parent.len());",
      "        assert!(y < self.parent.len());",
      "        return self.root(x) == self.root(y);",
      "    }",
      "    #[allow(dead_code)]",
      "    fn groups(&mut self) -> Vec<Vec<usize>> {",
      "        let n = self.parent.len();",
      "        let mut root_buf = vec![0; n];",
      "        let mut group_size = vec![0; n];",
      "        for i in 0..n {",
      "            root_buf[i] = self.root(i);",
      "            group_size[root_buf[i]] += 1;",
      "        }",
      "        let mut result = vec![Vec::new(); n];",
      "        for i in 0..n {",
      "            result[i].reserve(group_size[i]);",
      "        }",
      "        for i in 0..n {",
      "            result[root_buf[i]].push(i);",
      "        }",
      "        result",
      "            .into_iter()",
      "            .filter(|x| !x.is_empty())",
      "            .collect::<Vec<Vec<usize>>>()",
      "    }",
      "}"
    ]
  },
  ":updated_coordinate": {
    "scope": "rust",
    "prefix": ":updated_coordinate",
    "body": [
      "#[allow(dead_code)]",
      "#[allow(non_snake_case)]",
      "#[inline(always)]",
      "fn is_in(now: (usize, usize), dx: i64, dy: i64, H: usize, W: usize) -> bool {",
      "    let H = H as i64;",
      "    let W = W as i64;",
      "    let new_x = now.0 as i64 + dx;",
      "    let new_y = now.1 as i64 + dy;",
      "    return 0 <= new_x && new_x < H && 0 <= new_y && new_y < W;",
      "}",
      "#[allow(dead_code)]",
      "#[allow(non_snake_case)]",
      "#[inline(always)]",
      "fn updated_coordinate(",
      "    x: usize,",
      "    y: usize,",
      "    dx: i64,",
      "    dy: i64,",
      "    H: usize,",
      "    W: usize,",
      ") -> Option<(usize, usize)> {",
      "    if is_in((x, y), dx, dy, H, W) {",
      "        return Some(((x as i64 + dx) as usize, (y as i64 + dy) as usize));",
      "    } else {",
      "        return None;",
      "    }",
      "}"
    ]
  },
  "gcd": {
    "scope": "rust",
    "prefix": "gcd",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "gcd_list": {
    "scope": "rust",
    "prefix": "gcd_list",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn gcd_list(list: &[u64]) -> u64 {",
      "    list.iter().fold(list[0], |a, &b| gcd(a, b))",
      "}"
    ]
  },
  "lcm": {
    "scope": "rust",
    "prefix": "lcm",
    "body": [
      "#[allow(dead_code)]",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "mymath": {
    "scope": "rust",
    "prefix": "mymath",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  }
}
