{
  ":comb": {
    "scope": "rust",
    "prefix": ":comb",
    "body": [
      "struct CombUtil<Int>",
      "where",
      "    Int: PrimInt,",
      "{",
      "    fc: Vec<Int>,",
      "    ifc: Vec<Int>,",
      "    mod_value: Int,",
      "}",
      "impl<Int> CombUtil<Int>",
      "where",
      "    Int: PrimInt + Default,",
      "{",
      "    #[allow(dead_code)]",
      "    fn new(size: usize, mod_value: Int) -> Self {",
      "        let mut fc = vec![Int::default(); size + 1];",
      "        let mut ifc = vec![Int::default(); size + 1];",
      "        fc[0] = Int::from(1).unwrap();",
      "        for i in 1..=size {",
      "            fc[i] = fc[i - 1] * Int::from(i).unwrap() % mod_value;",
      "        }",
      "        ifc[size] = Self::inv(fc[size], mod_value);",
      "        for i in (0..size).rev() {",
      "            ifc[i] = ifc[i + 1] * Int::from(i + 1).unwrap() % mod_value;",
      "        }",
      "        Self { fc, ifc, mod_value }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn fact(&self, n: usize) -> Int {",
      "        self.fc[n]",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv_fact(&self, n: usize) -> Int {",
      "        self.ifc[n]",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv(n: Int, mod_value: Int) -> Int {",
      "        Self::pow(n, mod_value - Int::from(2).unwrap(), mod_value)",
      "    }",
      "    #[allow(dead_code)]",
      "    fn pow(n: Int, mut a: Int, mod_value: Int) -> Int {",
      "        let mut res = Int::from(1).unwrap();",
      "        let mut exp = n % mod_value;",
      "        while a > Int::from(0).unwrap() {",
      "            if a % Int::from(2).unwrap() == Int::from(1).unwrap() {",
      "                res = res * exp % mod_value;",
      "            }",
      "            exp = exp * exp % mod_value;",
      "            a = a / Int::from(2).unwrap();",
      "        }",
      "        res",
      "    }",
      "    #[allow(dead_code)]",
      "    fn npr(&self, n: usize, r: usize) -> Int {",
      "        if r > n {",
      "            Int::from(0).unwrap()",
      "        } else {",
      "            self.fc[n] * self.ifc[n - r] % self.mod_value",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn ncr(&self, n: i64, r: i64) -> Int {",
      "        if n < 0 || r < 0 || n < r {",
      "            Int::from(0).unwrap()",
      "        } else {",
      "            self.fc[n as usize] * self.ifc[r as usize] % self.mod_value * self.ifc[(n - r) as usize]",
      "                % self.mod_value",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn homo(&self, n: i64, r: i64) -> Int {",
      "        if r == 0 {",
      "            Int::from(1).unwrap()",
      "        } else if n < 0 || r < 0 {",
      "            Int::from(0).unwrap()",
      "        } else {",
      "            self.ncr(n + r - 1, r)",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "type Comb = CombUtil<i64>;"
    ]
  },
  ":dijkstra": {
    "scope": "rust",
    "prefix": ":dijkstra",
    "body": [
      "#[allow(dead_code)]",
      "fn dijkstra(graph: &Vec<Vec<(usize, i64)>>, start: usize) -> Vec<i64> {",
      "    let mut dist = vec![INF; graph.len()];",
      "    let mut heap = BinaryHeap::new();",
      "    dist[start] = 0;",
      "    heap.push((Reverse(0), start));",
      "    while let Some((Reverse(cost), position)) = heap.pop() {",
      "        if cost > dist[position] {",
      "            continue;",
      "        }",
      "        for &(to, to_cost) in &graph[position] {",
      "            let next_cost = cost + to_cost;",
      "            if next_cost < dist[to] {",
      "                heap.push((Reverse(next_cost), to));",
      "                dist[to] = next_cost;",
      "            }",
      "        }",
      "    }",
      "    return dist;",
      "}"
    ]
  },
  ":extgcd": {
    "scope": "rust",
    "prefix": ":extgcd",
    "body": [
      "#[allow(dead_code)]",
      "fn extgcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    fn _extgcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {",
      "        let mut g = a;",
      "        *x = 1;",
      "        *y = 0;",
      "        if b != 0 {",
      "            g = _extgcd(b, a % b, y, x);",
      "            *y -= (a / b) * *x;",
      "        }",
      "        g",
      "    }",
      "    let mut x = 0;",
      "    let mut y = 0;",
      "    let g = _extgcd(a, b, &mut x, &mut y);",
      "    (x, y, g)",
      "}",
      "#[allow(dead_code)]",
      "fn positive_extgcd(a: i64, b: i64) -> Option<(i64, i64, i64)> {",
      "    let (x, y, g) = extgcd(a, b);",
      "    let (a_g, b_g) = (a / g, b / g);",
      "    let r = x % b_g;",
      "    let px = if r >= 0 { r } else { r + b_g };",
      "    let py = y + (x - px) / b_g * a_g;",
      "    if py >= 0 {",
      "        Some((px, py, g))",
      "    } else {",
      "        None",
      "    }",
      "}"
    ]
  },
  ":lazy_segment_tree": {
    "scope": "rust",
    "prefix": ":lazy_segment_tree",
    "body": [
      "pub struct LazySegmentTree<S, F, E, T, G, H, I>",
      "where",
      "    S: Copy + Eq,",
      "    T: Copy + Eq,",
      "    F: Fn(S, S) -> S,",
      "    E: Fn() -> S,",
      "    G: Fn(T, S) -> S,",
      "    H: Fn() -> T,",
      "    I: Fn(T, T) -> T,",
      "{",
      "    value: Vec<S>,",
      "    op: F,",
      "    element: E,",
      "    lazy: Vec<T>,",
      "    mapping: G,",
      "    id: H,",
      "    composite: I,",
      "}",
      "impl<S, F, E, T, G, H, I> LazySegmentTree<S, F, E, T, G, H, I>",
      "where",
      "    S: Copy + Eq,",
      "    T: Copy + Eq,",
      "    F: Fn(S, S) -> S,",
      "    E: Fn() -> S,",
      "    G: Fn(T, S) -> S,",
      "    H: Fn() -> T,",
      "    I: Fn(T, T) -> T,",
      "{",
      "    pub fn new(size: usize, op: F, element: E, mapping: G, id: H, composite: I) -> Self {",
      "        let tree_size = size.next_power_of_two() * 2 - 1;",
      "        let value = vec![element(); tree_size];",
      "        let lazy = vec![id(); tree_size];",
      "        Self {",
      "            value,",
      "            op,",
      "            element,",
      "            lazy,",
      "            mapping,",
      "            id,",
      "            composite,",
      "        }",
      "    }",
      "    pub fn prod(&mut self, left: usize, right: usize) -> S {",
      "        assert!(left <= right);",
      "        if right == left {",
      "            (self.element)()",
      "        } else {",
      "            self._prod(0, left, right, 0, self.value.len() / 2 + 1)",
      "        }",
      "    }",
      "    fn _prod(",
      "        &mut self,",
      "        tree_index: usize,",
      "        search_left: usize,",
      "        search_right: usize,",
      "        left: usize,",
      "        right: usize,",
      "    ) -> S {",
      "        if search_left <= left && right <= search_right {",
      "            self.value[tree_index]",
      "        } else if right <= search_left || search_right <= left {",
      "            (self.element)()",
      "        } else {",
      "            if self.lazy[tree_index] != (self.id)() {",
      "                self.propagate(tree_index, left, right, left, right);",
      "            }",
      "            let mid = (left + right) / 2;",
      "            let (left_t_index, right_t_index) = self.get_children(tree_index);",
      "            let l_value = self._prod(left_t_index, search_left, search_right, left, mid);",
      "            let r_value = self._prod(right_t_index, search_left, search_right, mid, right);",
      "            (self.op)(l_value, r_value)",
      "        }",
      "    }",
      "    fn get_children(&self, tree_index: usize) -> (usize, usize) {",
      "        (tree_index * 2 + 1, tree_index * 2 + 2)",
      "    }",
      "    pub fn apply(&mut self, v: T, left: usize, right: usize) {",
      "        self._apply(v, 0, left, right, 0, self.value.len() / 2 + 1);",
      "    }",
      "    fn _apply(",
      "        &mut self,",
      "        v: T,",
      "        tree_index: usize,",
      "        search_left: usize,",
      "        search_right: usize,",
      "        left: usize,",
      "        right: usize,",
      "    ) {",
      "        if right <= search_left || search_right <= left {",
      "            return;",
      "        }",
      "        self.lazy[tree_index] = (self.composite)(v, self.lazy[tree_index]);",
      "        if search_left <= left && right <= search_right {",
      "            self.value[tree_index] = (self.mapping)(v, self.value[tree_index]);",
      "        } else {",
      "            self.propagate(tree_index, search_left, search_right, left, right);",
      "            let (left_t_index, right_t_index) = self.get_children(tree_index);",
      "            self.value[tree_index] = (self.op)(self.value[left_t_index], self.value[right_t_index]);",
      "        }",
      "    }",
      "    fn propagate(",
      "        &mut self,",
      "        tree_index: usize,",
      "        search_left: usize,",
      "        search_right: usize,",
      "        left: usize,",
      "        right: usize,",
      "    ) {",
      "        let lazy = self.lazy[tree_index];",
      "        self.lazy[tree_index] = (self.id)();",
      "        let mid = (left + right) / 2;",
      "        let (left_t_index, right_t_index) = self.get_children(tree_index);",
      "        self._apply(lazy, left_t_index, search_left, search_right, left, mid);",
      "        self._apply(lazy, right_t_index, search_left, search_right, mid, right);",
      "    }",
      "}"
    ]
  },
  ":mod_int": {
    "scope": "rust",
    "prefix": ":mod_int",
    "body": [
      "#[derive(Clone, Copy, Debug)]",
      "struct ModInt {",
      "    x: i64,",
      "    modulo: i64,",
      "}",
      "impl ModInt {",
      "    #[allow(dead_code)]",
      "    fn new(x: i64, modulo: i64) -> Self {",
      "        let x = if x >= 0 {",
      "            x % modulo",
      "        } else {",
      "            (modulo - (-x) % modulo) % modulo",
      "        };",
      "        ModInt { x, modulo }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn set(&mut self, x: i64) {",
      "        if x >= 0 {",
      "            self.x = x % self.modulo",
      "        } else {",
      "            self.x = (self.modulo - (-x) % self.modulo) % self.modulo",
      "        };",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv(&self) -> Self {",
      "        let mut a = self.x;",
      "        let mut b = self.modulo;",
      "        let mut u: i64 = 1;",
      "        let mut v: i64 = 0;",
      "        while b > 0 {",
      "            let t = a / b;",
      "            a -= t * b;",
      "            mem::swap(&mut a, &mut b);",
      "            u -= t * v;",
      "            mem::swap(&mut u, &mut v);",
      "        }",
      "        u %= self.modulo;",
      "        if u < 0 {",
      "            u += self.modulo;",
      "        }",
      "        return ModInt {",
      "            x: u,",
      "            modulo: self.modulo,",
      "        };",
      "    }",
      "    #[allow(dead_code)]",
      "    fn pow(&self, mut n: i64) -> Self {",
      "        let mut a = self.x;",
      "        let mut res: i64 = 1;",
      "        while n > 0 {",
      "            if n & 1 == 1 {",
      "                res = (res * a) % self.modulo;",
      "            }",
      "            a = (a * a) % self.modulo;",
      "            n >>= 1;",
      "        }",
      "        return ModInt {",
      "            x: res,",
      "            modulo: self.modulo,",
      "        };",
      "    }",
      "}",
      "impl fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "        write!(f, \"{}\", self.x)",
      "    }",
      "}",
      "impl ops::Neg for ModInt {",
      "    type Output = ModInt;",
      "    fn neg(self) -> Self::Output {",
      "        ModInt::new(-self.x, self.modulo)",
      "    }",
      "}",
      "impl ops::Add<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: Self) -> Self::Output {",
      "        return ModInt::new(self.x + rhs.x, self.modulo);",
      "    }",
      "}",
      "impl ops::Add<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: i64) -> Self::Output {",
      "        return ModInt::new(self.x + rhs, self.modulo);",
      "    }",
      "}",
      "impl<'a> ops::AddAssign<&'a Self> for ModInt {",
      "    fn add_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x + rhs.x);",
      "    }",
      "}",
      "impl ops::AddAssign<i64> for ModInt {",
      "    fn add_assign(&mut self, rhs: i64) {",
      "        self.set(self.x + rhs);",
      "    }",
      "}",
      "impl ops::Sub<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: Self) -> Self::Output {",
      "        return ModInt::new(self.x - rhs.x, self.modulo);",
      "    }",
      "}",
      "impl ops::Sub<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: i64) -> Self::Output {",
      "        return ModInt::new(self.x - rhs, self.modulo);",
      "    }",
      "}",
      "impl<'a> ops::SubAssign<&'a Self> for ModInt {",
      "    fn sub_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x - rhs.x);",
      "    }",
      "}",
      "impl ops::SubAssign<i64> for ModInt {",
      "    fn sub_assign(&mut self, rhs: i64) {",
      "        self.set(self.x - rhs);",
      "    }",
      "}",
      "impl ops::Mul<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: Self) -> Self::Output {",
      "        ModInt::new(self.x * rhs.x, self.modulo)",
      "    }",
      "}",
      "impl ops::Mul<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: i64) -> Self::Output {",
      "        ModInt::new(self.x * rhs, self.modulo)",
      "    }",
      "}",
      "impl<'a> ops::MulAssign<&'a Self> for ModInt {",
      "    fn mul_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x * rhs.x);",
      "    }",
      "}",
      "impl ops::MulAssign<i64> for ModInt {",
      "    fn mul_assign(&mut self, rhs: i64) {",
      "        self.set(self.x * rhs);",
      "    }",
      "}",
      "impl ops::Div<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: Self) -> Self::Output {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl ops::Div<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: i64) -> Self::Output {",
      "        self * ModInt::new(rhs, self.modulo).inv()",
      "    }",
      "}",
      "impl<'a> ops::DivAssign<&'a Self> for ModInt {",
      "    fn div_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x * rhs.inv().x);",
      "    }",
      "}",
      "impl ops::DivAssign<i64> for ModInt {",
      "    fn div_assign(&mut self, rhs: i64) {",
      "        self.set(self.x * ModInt::new(rhs, self.modulo).inv().x);",
      "    }",
      "}",
      "impl cmp::PartialEq<ModInt> for ModInt {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.x == other.x",
      "    }",
      "    fn ne(&self, other: &Self) -> bool {",
      "        self.x != other.x",
      "    }",
      "}",
      "impl cmp::PartialEq<i64> for ModInt {",
      "    fn eq(&self, other: &i64) -> bool {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        self.x == other.x",
      "    }",
      "    fn ne(&self, other: &i64) -> bool {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        self.x != other.x",
      "    }",
      "}",
      "impl cmp::PartialOrd<ModInt> for ModInt {",
      "    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {",
      "        if self.x == other.x {",
      "            Some(cmp::Ordering::Equal)",
      "        } else if self.x > other.x {",
      "            Some(cmp::Ordering::Greater)",
      "        } else {",
      "            Some(cmp::Ordering::Less)",
      "        }",
      "    }",
      "}",
      "impl cmp::PartialOrd<i64> for ModInt {",
      "    fn partial_cmp(&self, other: &i64) -> Option<cmp::Ordering> {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        if self.x == other.x {",
      "            Some(cmp::Ordering::Equal)",
      "        } else if self.x > other.x {",
      "            Some(cmp::Ordering::Greater)",
      "        } else {",
      "            Some(cmp::Ordering::Less)",
      "        }",
      "    }",
      "}"
    ]
  },
  ":rotated": {
    "scope": "rust",
    "prefix": ":rotated",
    "body": [
      "#[allow(dead_code)]",
      "fn rotated<T: Default + Clone>(grid: &Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let mut ret = vec![vec![Default::default(); grid.len()]; grid[0].len()];",
      "    for i in 0..grid[0].len() {",
      "        for j in 0..grid.len() {",
      "            ret[i][j] = grid[grid.len() - 1 - j][i].clone();",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  ":shifted": {
    "scope": "rust",
    "prefix": ":shifted",
    "body": [
      "#[allow(dead_code)]",
      "fn shifted<T: Default + Clone>(grid: &Vec<Vec<T>>, dx: i64, dy: i64, default: T) -> Vec<Vec<T>> {",
      "    let mut ret = vec![vec![Default::default(); grid[0].len()]; grid.len()];",
      "    for i in 0..grid.len() {",
      "        for j in 0..grid[0].len() {",
      "            let mut value = default.clone();",
      "            let nx = i as i64 - dx;",
      "            let ny = j as i64 - dy;",
      "            if 0 <= nx && nx < grid.len() as i64 && 0 <= ny && ny < grid[0].len() as i64 {",
      "                value = grid[nx as usize][ny as usize].clone();",
      "            }",
      "            ret[i][j] = value;",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  ":union_find": {
    "scope": "rust",
    "prefix": ":union_find",
    "body": [
      "#[derive(Debug)]",
      "struct UnionFind {",
      "    parent: Vec<i32>,",
      "}",
      "impl UnionFind {",
      "    #[allow(dead_code)]",
      "    fn new(size: usize) -> Self {",
      "        UnionFind {",
      "            parent: vec![-1; size],",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn unite(&mut self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.parent.len());",
      "        assert!(y < self.parent.len());",
      "        let mut x = self.root(x);",
      "        let mut y = self.root(y);",
      "        if x == y {",
      "            return false;",
      "        }",
      "        if self.parent[x] > self.parent[y] {",
      "            mem::swap(&mut x, &mut y);",
      "        }",
      "        self.parent[x] += self.parent[y];",
      "        self.parent[y] = x as i32;",
      "        return true;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn root(&mut self, k: usize) -> usize {",
      "        assert!(k < self.parent.len());",
      "        if self.parent[k as usize] < 0 {",
      "            return k;",
      "        }",
      "        self.parent[k as usize] = self.root(self.parent[k] as usize) as i32;",
      "        return self.parent[k] as usize;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn size(&mut self, k: usize) -> usize {",
      "        assert!(k < self.parent.len());",
      "        let x = self.root(k);",
      "        return -self.parent[x] as usize;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn is_same(&mut self, x: usize, y: usize) -> bool {",
      "        assert!(x < self.parent.len());",
      "        assert!(y < self.parent.len());",
      "        return self.root(x) == self.root(y);",
      "    }",
      "    #[allow(dead_code)]",
      "    fn groups(&mut self) -> Vec<Vec<usize>> {",
      "        let n = self.parent.len();",
      "        let mut root_buf = vec![0; n];",
      "        let mut group_size = vec![0; n];",
      "        for i in 0..n {",
      "            root_buf[i] = self.root(i);",
      "            group_size[root_buf[i]] += 1;",
      "        }",
      "        let mut result = vec![Vec::new(); n];",
      "        for i in 0..n {",
      "            result[i].reserve(group_size[i]);",
      "        }",
      "        for i in 0..n {",
      "            result[root_buf[i]].push(i);",
      "        }",
      "        result",
      "            .into_iter()",
      "            .filter(|x| !x.is_empty())",
      "            .collect::<Vec<Vec<usize>>>()",
      "    }",
      "}"
    ]
  },
  ":updated_coordinate": {
    "scope": "rust",
    "prefix": ":updated_coordinate",
    "body": [
      "#[allow(dead_code)]",
      "#[allow(non_snake_case)]",
      "fn is_in(now: (usize, usize), dx: i64, dy: i64, H: usize, W: usize) -> bool {",
      "    let H = H as i64;",
      "    let W = W as i64;",
      "    let new_x = now.0 as i64 + dx;",
      "    let new_y = now.1 as i64 + dy;",
      "    return 0 <= new_x && new_x < H && 0 <= new_y && new_y < W;",
      "}",
      "#[allow(dead_code)]",
      "#[allow(non_snake_case)]",
      "fn updated_coordinate(",
      "    x: usize,",
      "    y: usize,",
      "    dx: i64,",
      "    dy: i64,",
      "    H: usize,",
      "    W: usize,",
      ") -> Option<(usize, usize)> {",
      "    if is_in((x, y), dx, dy, H, W) {",
      "        return Some(((x as i64 + dx) as usize, (y as i64 + dy) as usize));",
      "    } else {",
      "        return None;",
      "    }",
      "}"
    ]
  },
  "gcd": {
    "scope": "rust",
    "prefix": "gcd",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "gcd_list": {
    "scope": "rust",
    "prefix": "gcd_list",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn gcd_list(list: &[u64]) -> u64 {",
      "    list.iter().fold(list[0], |a, &b| gcd(a, b))",
      "}"
    ]
  },
  "lcm": {
    "scope": "rust",
    "prefix": "lcm",
    "body": [
      "#[allow(dead_code)]",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "mymath": {
    "scope": "rust",
    "prefix": "mymath",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  }
}
