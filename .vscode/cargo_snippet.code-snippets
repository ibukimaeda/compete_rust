{
  ":is_in": {
    "scope": "rust",
    "prefix": ":is_in",
    "body": [
      "fn is_in(now: (usize, usize), dx: i64, dy: i64, H: usize, W: usize) -> bool {",
      "    let H = H as i64;",
      "    let W = W as i64;",
      "    let new_x = now.0 as i64 + dx;",
      "    let new_y = now.1 as i64 + dy;",
      "    return 0 <= new_x && new_x < H && 0 <= new_y && new_y < W;",
      "}"
    ]
  },
  ":mod_int": {
    "scope": "rust",
    "prefix": ":mod_int",
    "body": [
      "#[derive(Clone, Copy, Debug)]",
      "struct ModInt {",
      "    x: i64,",
      "    modulo: i64,",
      "}",
      "impl ModInt {",
      "    #[allow(dead_code)]",
      "    fn new(x: i64, modulo: i64) -> Self {",
      "        let x = if x >= 0 {",
      "            x % modulo",
      "        } else {",
      "            (modulo - (-x) % modulo) % modulo",
      "        };",
      "        ModInt { x, modulo }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn set(&mut self, x: i64) {",
      "        if x >= 0 {",
      "            self.x = x % self.modulo",
      "        } else {",
      "            self.x = (self.modulo - (-x) % self.modulo) % self.modulo",
      "        };",
      "    }",
      "    #[allow(dead_code)]",
      "    fn inv(&self) -> Self {",
      "        let mut a = self.x;",
      "        let mut b = self.modulo;",
      "        let mut u: i64 = 1;",
      "        let mut v: i64 = 0;",
      "        while b > 0 {",
      "            let t = a / b;",
      "            a -= t * b;",
      "            mem::swap(&mut a, &mut b);",
      "            u -= t * v;",
      "            mem::swap(&mut u, &mut v);",
      "        }",
      "        u %= self.modulo;",
      "        if u < 0 {",
      "            u += self.modulo;",
      "        }",
      "        return ModInt {",
      "            x: u,",
      "            modulo: self.modulo,",
      "        };",
      "    }",
      "    #[allow(dead_code)]",
      "    fn pow(&self, mut n: i64) -> Self {",
      "        let mut a = self.x;",
      "        let mut res: i64 = 1;",
      "        while n > 0 {",
      "            if n & 1 == 1 {",
      "                res = (res * a) % self.modulo;",
      "            }",
      "            a = (a * a) % self.modulo;",
      "            n >>= 1;",
      "        }",
      "        return ModInt {",
      "            x: res,",
      "            modulo: self.modulo,",
      "        };",
      "    }",
      "}",
      "impl fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
      "        write!(f, \"{}\", self.x)",
      "    }",
      "}",
      "impl ops::Neg for ModInt {",
      "    type Output = ModInt;",
      "    fn neg(self) -> Self::Output {",
      "        ModInt::new(-self.x, self.modulo)",
      "    }",
      "}",
      "impl ops::Add<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: Self) -> Self::Output {",
      "        return ModInt::new(self.x + rhs.x, self.modulo);",
      "    }",
      "}",
      "impl ops::Add<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: i64) -> Self::Output {",
      "        return ModInt::new(self.x + rhs, self.modulo);",
      "    }",
      "}",
      "impl<'a> ops::AddAssign<&'a Self> for ModInt {",
      "    fn add_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x + rhs.x);",
      "    }",
      "}",
      "impl ops::AddAssign<i64> for ModInt {",
      "    fn add_assign(&mut self, rhs: i64) {",
      "        self.set(self.x + rhs);",
      "    }",
      "}",
      "impl ops::Sub<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: Self) -> Self::Output {",
      "        return ModInt::new(self.x - rhs.x, self.modulo);",
      "    }",
      "}",
      "impl ops::Sub<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: i64) -> Self::Output {",
      "        return ModInt::new(self.x - rhs, self.modulo);",
      "    }",
      "}",
      "impl<'a> ops::SubAssign<&'a Self> for ModInt {",
      "    fn sub_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x - rhs.x);",
      "    }",
      "}",
      "impl ops::SubAssign<i64> for ModInt {",
      "    fn sub_assign(&mut self, rhs: i64) {",
      "        self.set(self.x - rhs);",
      "    }",
      "}",
      "impl ops::Mul<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: Self) -> Self::Output {",
      "        ModInt::new(self.x * rhs.x, self.modulo)",
      "    }",
      "}",
      "impl ops::Mul<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: i64) -> Self::Output {",
      "        ModInt::new(self.x * rhs, self.modulo)",
      "    }",
      "}",
      "impl<'a> ops::MulAssign<&'a Self> for ModInt {",
      "    fn mul_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x * rhs.x);",
      "    }",
      "}",
      "impl ops::MulAssign<i64> for ModInt {",
      "    fn mul_assign(&mut self, rhs: i64) {",
      "        self.set(self.x * rhs);",
      "    }",
      "}",
      "impl ops::Div<ModInt> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: Self) -> Self::Output {",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl ops::Div<i64> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: i64) -> Self::Output {",
      "        self * ModInt::new(rhs, self.modulo).inv()",
      "    }",
      "}",
      "impl<'a> ops::DivAssign<&'a Self> for ModInt {",
      "    fn div_assign(&mut self, rhs: &Self) {",
      "        self.set(self.x * rhs.inv().x);",
      "    }",
      "}",
      "impl ops::DivAssign<i64> for ModInt {",
      "    fn div_assign(&mut self, rhs: i64) {",
      "        self.set(self.x * ModInt::new(rhs, self.modulo).inv().x);",
      "    }",
      "}",
      "impl cmp::PartialEq<ModInt> for ModInt {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.x == other.x",
      "    }",
      "    fn ne(&self, other: &Self) -> bool {",
      "        self.x != other.x",
      "    }",
      "}",
      "impl cmp::PartialEq<i64> for ModInt {",
      "    fn eq(&self, other: &i64) -> bool {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        self.x == other.x",
      "    }",
      "    fn ne(&self, other: &i64) -> bool {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        self.x != other.x",
      "    }",
      "}",
      "impl cmp::PartialOrd<ModInt> for ModInt {",
      "    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {",
      "        if self.x == other.x {",
      "            Some(cmp::Ordering::Equal)",
      "        } else if self.x > other.x {",
      "            Some(cmp::Ordering::Greater)",
      "        } else {",
      "            Some(cmp::Ordering::Less)",
      "        }",
      "    }",
      "}",
      "impl cmp::PartialOrd<i64> for ModInt {",
      "    fn partial_cmp(&self, other: &i64) -> Option<cmp::Ordering> {",
      "        let other = ModInt::new(*other, self.modulo);",
      "        if self.x == other.x {",
      "            Some(cmp::Ordering::Equal)",
      "        } else if self.x > other.x {",
      "            Some(cmp::Ordering::Greater)",
      "        } else {",
      "            Some(cmp::Ordering::Less)",
      "        }",
      "    }",
      "}"
    ]
  },
  ":rotated": {
    "scope": "rust",
    "prefix": ":rotated",
    "body": [
      "fn rotated<T: Default + Clone>(grid: &Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let mut ret = vec![vec![Default::default(); grid.len()]; grid[0].len()];",
      "    for i in 0..grid[0].len() {",
      "        for j in 0..grid.len() {",
      "            ret[i][j] = grid[grid.len() - 1 - j][i].clone();",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  ":shifted": {
    "scope": "rust",
    "prefix": ":shifted",
    "body": [
      "fn shifted<T: Default + Clone>(grid: &Vec<Vec<T>>, dx: i64, dy: i64, default: T) -> Vec<Vec<T>> {",
      "    let mut ret = vec![vec![Default::default(); grid[0].len()]; grid.len()];",
      "    for i in 0..grid.len() {",
      "        for j in 0..grid[0].len() {",
      "            let mut value = default.clone();",
      "            let nx = i as i64 - dx;",
      "            let ny = j as i64 - dy;",
      "            if 0 <= nx && nx < grid.len() as i64 && 0 <= ny && ny < grid[0].len() as i64 {",
      "                value = grid[nx as usize][ny as usize].clone();",
      "            }",
      "            ret[i][j] = value;",
      "        }",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  ":union_find": {
    "scope": "rust",
    "prefix": ":union_find",
    "body": [
      "#[derive(Debug)]",
      "struct UnionFind {",
      "    data: Vec<i64>,",
      "}",
      "impl UnionFind {",
      "    #[allow(dead_code)]",
      "    fn new(size: usize) -> Self {",
      "        UnionFind {",
      "            data: vec![-1; size],",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn unite(&mut self, mut x: i64, mut y: i64) -> bool {",
      "        x = self.root(x);",
      "        y = self.root(y);",
      "        if x == y {",
      "            return false;",
      "        }",
      "        if self.data[x as usize] > self.data[y as usize] {",
      "            mem::swap(&mut x, &mut y);",
      "        }",
      "        self.data[x as usize] += self.data[y as usize];",
      "        self.data[y as usize] = x;",
      "        return true;",
      "    }",
      "    #[allow(dead_code)]",
      "    fn root(&mut self, k: i64) -> i64 {",
      "        if self.data[k as usize] < 0 {",
      "            return k;",
      "        } else {",
      "            self.data[k as usize] = self.root(self.data[k as usize]);",
      "            return self.data[k as usize];",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    fn size(&mut self, k: i64) -> i64 {",
      "        let x: usize = self.root(k) as usize;",
      "        return -self.data[x];",
      "    }",
      "    #[allow(dead_code)]",
      "    fn is_same(&mut self, x: i64, y: i64) -> bool {",
      "        return self.root(x) == self.root(y);",
      "    }",
      "    #[allow(dead_code)]",
      "    fn groups(&mut self) -> Vec<Vec<i64>> {",
      "        let n = self.data.len();",
      "        let mut ret: Vec<Vec<i64>> = vec![vec![0; 0]; n];",
      "        for i in 0..n {",
      "            ret[self.root(i as i64) as usize].push(i as i64);",
      "        }",
      "        let mut i = 0;",
      "        while i < ret.len() {",
      "            if ret[i].is_empty() {",
      "                ret.remove(i);",
      "            } else {",
      "                i += 1;",
      "            }",
      "        }",
      "        return ret;",
      "    }",
      "}"
    ]
  },
  ":updated_coordinate": {
    "scope": "rust",
    "prefix": ":updated_coordinate",
    "body": [
      "fn updated_coordinate(x: usize, y: usize, dx: i64, dy: i64) -> (usize, usize) {",
      "    return ((x as i64 + dx) as usize, (y as i64 + dy) as usize);",
      "}"
    ]
  },
  "gcd": {
    "scope": "rust",
    "prefix": "gcd",
    "body": [
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "gcd_list": {
    "scope": "rust",
    "prefix": "gcd_list",
    "body": [
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "fn gcd_list(list: &[u64]) -> u64 {",
      "    list.iter().fold(list[0], |a, &b| gcd(a, b))",
      "}"
    ]
  },
  "lcm": {
    "scope": "rust",
    "prefix": "lcm",
    "body": [
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "mymath": {
    "scope": "rust",
    "prefix": "mymath",
    "body": [
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  }
}
