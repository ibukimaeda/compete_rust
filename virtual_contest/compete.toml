# Path to the test file (Liquid template)
#
# Variables:
#
# - `manifest_dir`: Package directory
# - `contest`:      Contest ID (e.g. "abc100")
# - `bin_name`:     Name of a `bin` target (e.g. "abc100-a")
# - `bin_alias`:    "Alias" for a `bin` target defined in `pacakge.metadata.cargo-compete` (e.g. "a")
# - `problem`:      Alias for `bin_alias` (deprecated)
#
# Additional filters:
#
# - `kebabcase`: Convert to kebab case (by using the `heck` crate)
test-suite = "{{ manifest_dir }}/testcases/{{ bin_alias }}.yml"

# Open files with the command (`jq` command that outputs `string[] | string[][]`)
#
# VSCode:
#open = '[["code", "-a", .manifest_dir], ["code"] + (.paths | map([.src, .test_suite]) | flatten)]'
# Emacs:
#open = '["emacsclient", "-n"] + (.paths | map([.src, .test_suite]) | flatten)'

[template]
src = "#![allow(non_snake_case)]\n#![allow(unused_imports)]\nuse itertools::Itertools;\nuse proconio::{\n    fastout, input, input_interactive,\n    marker::{Chars, Isize1, Usize1},\n};\nuse rand::{thread_rng, Rng};\nuse std::cmp;\nuse std::cmp::Reverse;\nuse std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\nuse std::default;\nuse std::fmt;\nuse std::mem;\nuse std::ops;\nuse std::vec;\n\n#[allow(dead_code)]\n// const MOD: i64 = 1_000_000_007;\n// const MOD : i64 = 1_000_000_009;\nconst MOD: i64 = 998_244_353;\n\n#[allow(dead_code)]\nconst INF: i64 = 1_010_000_000_000_000_017;\n\nconst DX: [i64; 4] = [0, 0, 1, -1];\nconst DY: [i64; 4] = [1, -1, 0, 0];\n\n#[allow(non_snake_case)]\nfn main() {}\n\n#[allow(dead_code)]\nfn yes() {\n    println!(\"Yes\");\n}\n\n#[allow(dead_code)]\nfn no() {\n    println!(\"No\");\n}\n\n#[allow(dead_code)]\nfn say<T: std::fmt::Display>(v: T) {\n    println!(\"{}\", v);\n}\n\n#[allow(dead_code)]\nfn print_vec<T: std::fmt::Display>(v: &Vec<T>) {\n    let mut first = true;\n    for value in v {\n        if first {\n            #[cfg(debug_assertions)]\n            eprint!(\"{}\", *value);\n            first = false;\n        } else {\n            #[cfg(debug_assertions)]\n            eprint!(\" {}\", *value);\n        }\n    }\n    #[cfg(debug_assertions)]\n    eprintln!();\n}\n\n#[allow(dead_code)]\nfn print_vec2<T: std::fmt::Display>(v: &Vec<Vec<T>>) {\n    for _v in v {\n        print_vec(_v);\n    }\n}\n\nfn is_in(now: (usize, usize), dx: i64, dy: i64, H: usize, W: usize) -> bool {\n    let H = H as i64;\n    let W = W as i64;\n    let new_x = now.0 as i64 + dx;\n    let new_y = now.1 as i64 + dy;\n\n    return 0 <= new_x && new_x < H && 0 <= new_y && new_y < W;\n}\n\nfn updated_coordinate(x: usize, y: usize, dx: i64, dy: i64) -> (usize, usize) {\n    return ((x as i64 + dx) as usize, (y as i64 + dy) as usize);\n}\n\n#[derive(Debug)]\nstruct UnionFind {\n    // https://qiita.com/ofutonton/items/c17dfd33fc542c222396\n    data: Vec<i64>,\n}\n\nimpl UnionFind {\n    #[allow(dead_code)]\n    fn new(size: usize) -> Self {\n        UnionFind {\n            data: vec![-1; size],\n        }\n    }\n\n    #[allow(dead_code)]\n    fn unite(&mut self, mut x: i64, mut y: i64) -> bool {\n        // xと y を結合\n        x = self.root(x);\n        y = self.root(y);\n\n        if x == y {\n            return false;\n        }\n        if self.data[x as usize] > self.data[y as usize] {\n            mem::swap(&mut x, &mut y);\n        }\n\n        self.data[x as usize] += self.data[y as usize];\n        self.data[y as usize] = x;\n        return true;\n    }\n\n    #[allow(dead_code)]\n    fn root(&mut self, k: i64) -> i64 {\n        // k の属する木の根を探索\n        if self.data[k as usize] < 0 {\n            return k;\n        } else {\n            self.data[k as usize] = self.root(self.data[k as usize]);\n            return self.data[k as usize];\n        }\n    }\n\n    #[allow(dead_code)]\n    fn size(&mut self, k: i64) -> i64 {\n        // k の属する木の大きさを返す\n        let x: usize = self.root(k) as usize;\n        return -self.data[x];\n    }\n\n    #[allow(dead_code)]\n    fn is_same(&mut self, x: i64, y: i64) -> bool {\n        // x と y の属する木が同じかどうか\n        return self.root(x) == self.root(y);\n    }\n\n    #[allow(dead_code)]\n    fn groups(&mut self) -> Vec<Vec<i64>> {\n        let n = self.data.len();\n        let mut ret: Vec<Vec<i64>> = vec![vec![0; 0]; n];\n        for i in 0..n {\n            ret[self.root(i as i64) as usize].push(i as i64);\n        }\n\n        let mut i = 0;\n        while i < ret.len() {\n            if ret[i].is_empty() {\n                ret.remove(i);\n            } else {\n                i += 1;\n            }\n        }\n\n        return ret;\n    }\n}\n\n#[derive(Clone, Copy, Debug)]\nstruct ModInt {\n    x: i64,\n    modulo: i64,\n}\n\nimpl ModInt {\n    #[allow(dead_code)]\n    fn new(x: i64, modulo: i64) -> Self {\n        let x = if x >= 0 {\n            x % modulo\n        } else {\n            (modulo - (-x) % modulo) % modulo\n        };\n        ModInt { x, modulo }\n    }\n\n    #[allow(dead_code)]\n    fn set(&mut self, x: i64) {\n        if x >= 0 {\n            self.x = x % self.modulo\n        } else {\n            self.x = (self.modulo - (-x) % self.modulo) % self.modulo\n        };\n    }\n\n    #[allow(dead_code)]\n    fn inv(&self) -> Self {\n        // (self.x)^-1\n        // https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a\n        let mut a = self.x;\n        let mut b = self.modulo;\n        let mut u: i64 = 1;\n        let mut v: i64 = 0;\n\n        while b > 0 {\n            let t = a / b;\n            a -= t * b;\n            mem::swap(&mut a, &mut b);\n            u -= t * v;\n            mem::swap(&mut u, &mut v);\n        }\n\n        u %= self.modulo;\n        if u < 0 {\n            u += self.modulo;\n        }\n\n        return ModInt {\n            x: u,\n            modulo: self.modulo,\n        };\n    }\n\n    #[allow(dead_code)]\n    fn pow(&self, mut n: i64) -> Self {\n        // (self.x)^n\n        let mut a = self.x;\n        let mut res: i64 = 1;\n\n        while n > 0 {\n            if n & 1 == 1 {\n                res = (res * a) % self.modulo;\n            }\n            a = (a * a) % self.modulo;\n            n >>= 1;\n        }\n\n        return ModInt {\n            x: res,\n            modulo: self.modulo,\n        };\n    }\n}\n\nimpl fmt::Display for ModInt {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.x)\n    }\n}\n\nimpl ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt::new(-self.x, self.modulo)\n    }\n}\n\nimpl ops::Add<ModInt> for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: Self) -> Self::Output {\n        return ModInt::new(self.x + rhs.x, self.modulo);\n    }\n}\n\nimpl ops::Add<i64> for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: i64) -> Self::Output {\n        return ModInt::new(self.x + rhs, self.modulo);\n    }\n}\n\nimpl<'a> ops::AddAssign<&'a Self> for ModInt {\n    fn add_assign(&mut self, rhs: &Self) {\n        self.set(self.x + rhs.x);\n    }\n}\n\nimpl ops::AddAssign<i64> for ModInt {\n    fn add_assign(&mut self, rhs: i64) {\n        self.set(self.x + rhs);\n    }\n}\n\nimpl ops::Sub<ModInt> for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: Self) -> Self::Output {\n        return ModInt::new(self.x - rhs.x, self.modulo);\n    }\n}\n\nimpl ops::Sub<i64> for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: i64) -> Self::Output {\n        return ModInt::new(self.x - rhs, self.modulo);\n    }\n}\n\nimpl<'a> ops::SubAssign<&'a Self> for ModInt {\n    fn sub_assign(&mut self, rhs: &Self) {\n        self.set(self.x - rhs.x);\n    }\n}\n\nimpl ops::SubAssign<i64> for ModInt {\n    fn sub_assign(&mut self, rhs: i64) {\n        self.set(self.x - rhs);\n    }\n}\n\nimpl ops::Mul<ModInt> for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: Self) -> Self::Output {\n        ModInt::new(self.x * rhs.x, self.modulo)\n    }\n}\n\nimpl ops::Mul<i64> for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: i64) -> Self::Output {\n        ModInt::new(self.x * rhs, self.modulo)\n    }\n}\n\nimpl<'a> ops::MulAssign<&'a Self> for ModInt {\n    fn mul_assign(&mut self, rhs: &Self) {\n        self.set(self.x * rhs.x);\n    }\n}\n\nimpl ops::MulAssign<i64> for ModInt {\n    fn mul_assign(&mut self, rhs: i64) {\n        self.set(self.x * rhs);\n    }\n}\n\nimpl ops::Div<ModInt> for ModInt {\n    type Output = ModInt;\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.inv()\n    }\n}\n\nimpl ops::Div<i64> for ModInt {\n    type Output = ModInt;\n    fn div(self, rhs: i64) -> Self::Output {\n        self * ModInt::new(rhs, self.modulo).inv()\n    }\n}\n\nimpl<'a> ops::DivAssign<&'a Self> for ModInt {\n    fn div_assign(&mut self, rhs: &Self) {\n        self.x *= rhs.inv().x;\n    }\n}\n\nimpl ops::DivAssign<i64> for ModInt {\n    fn div_assign(&mut self, rhs: i64) {\n        self.x *= ModInt::new(rhs, self.modulo).inv().x;\n    }\n}\n\nimpl cmp::PartialEq<ModInt> for ModInt {\n    fn eq(&self, other: &Self) -> bool {\n        self.x == other.x\n    }\n\n    fn ne(&self, other: &Self) -> bool {\n        self.x != other.x\n    }\n}\n\nimpl cmp::PartialEq<i64> for ModInt {\n    fn eq(&self, other: &i64) -> bool {\n        let other = ModInt::new(*other, self.modulo);\n        self.x == other.x\n    }\n\n    fn ne(&self, other: &i64) -> bool {\n        let other = ModInt::new(*other, self.modulo);\n        self.x != other.x\n    }\n}\n\nimpl cmp::PartialOrd<ModInt> for ModInt {\n    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n        if self.x == other.x {\n            Some(cmp::Ordering::Equal)\n        } else if self.x > other.x {\n            Some(cmp::Ordering::Greater)\n        } else {\n            Some(cmp::Ordering::Less)\n        }\n    }\n}\n\nimpl cmp::PartialOrd<i64> for ModInt {\n    fn partial_cmp(&self, other: &i64) -> Option<cmp::Ordering> {\n        let other = ModInt::new(*other, self.modulo);\n        if self.x == other.x {\n            Some(cmp::Ordering::Equal)\n        } else if self.x > other.x {\n            Some(cmp::Ordering::Greater)\n        } else {\n            Some(cmp::Ordering::Less)\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! min {\n    // 1 == min!(3, 2, 1)\n\n    // 引数が 1個なら，そのまま返す\n    ($a:expr $(,)*) => {{\n        $a\n    }};\n\n    // 引数が 2個なら std::cmp::min を使用する\n    ($a:expr, &b:expr $(,)*) => {{\n        std::cmp::min($a, $b)\n    }};\n\n    // 引数が 3個以上なら，再帰的に min! マクロを呼び出す\n    ($a:expr, $($rest:expr),+ $(,)*) => {{\n        std::cmp::min($a, min!($($rest),+))\n    }};\n}\n\n#[macro_export]\nmacro_rules! max {\n    // 3 == max!(3, 2, 1)\n\n    // 引数が 1個なら，そのまま返す\n    ($a:expr $(,)*) => {{\n        $a\n    }};\n\n    // 引数が 2個なら std::cmp::max を使用する\n    ($a:expr, &b:expr $(,)*) => {{\n        std::cmp::max($a, $b)\n    }};\n\n    // 引数が 3個以上なら，再帰的に max! マクロを呼び出す\n    ($a:expr, $($rest:expr),+ $(,)*) => {{\n        std::cmp::max($a, max!($($rest),+))\n    }};\n}\n\n#[macro_export]\nmacro_rules! chmin {\n    ($base:expr, $($cmps:expr),+ $(,)*) => {{\n        // 第2引数以降の部分に関して、min! を使用して最小値を求める\n        let cmp_min = min!($($cmps),+);\n\n        // それが第1引数より小さかったら、更新して true を返す\n        if $base > cmp_min {\n            $base = cmp_min;\n            true\n        } else {\n            // 更新が不要なので、false を返す\n            false\n        }\n    }};\n}\n\n#[macro_export]\nmacro_rules! chmax {\n    ($base:expr, $($cmps:expr),+ $(,)*) => {{\n        // 第2引数以降の部分に関して、max! を使用して最大値を求める\n        let cmp_max = max!($($cmps),+);\n\n        // それが第1引数より大きかったら、更新して true を返す\n        if $base < cmp_max {\n            $base = cmp_max;\n            true\n        } else {\n            // 更新が不要なので、false を返す\n            false\n        }\n    }};\n}\n\n#[macro_export]\nmacro_rules! debug {\n    ($($a:expr),* $(,)*) => {\n        #[cfg(debug_assertions)]\n        eprintln!(concat!($(\"| \", stringify!($a), \"={:?} \"),*, \"|\"), $(&$a),*);\n    };\n}\n\n#[macro_export]\nmacro_rules! nested_vec {\n    ($e:expr; $n:expr) => {\n        vec![$e; $n]\n    };\n    ($e:expr; $n:expr $(; $m:expr)+) => {\n        vec![nested_vec!($e $(; $m)+); $n]\n    };\n}\n\n// https://zenn.dev/qnighy/articles/a62e5c2a6ba8ef#swap%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E8%A9%B3%E3%81%97%E3%81%8F\n#[macro_export]\nmacro_rules! swap {\n    ($x: expr, $y: expr) => {\n        $crate::rotate!($x, $y)\n    };\n    ($x: expr, $y: expr,) => {\n        $crate::rotate!($x, $y)\n    };\n}\n\n#[macro_export]\nmacro_rules! rotate {\n    ($x: expr, $($y: expr),*) => {\n        {\n            let value = $crate::take!($x);\n            $(\n                let value = $crate::Replace::replace($y, value);\n            )*\n            let _ = $crate::Replace::replace($x, value);\n        }\n    };\n    ($x: expr) => {\n        $crate::rotate!($x,)\n    };\n    ($x: expr, $($y: expr),*,) => {\n        $crate::rotate!($x, $($y),*)\n    };\n}\n\nuse core::cell::{Cell, RefCell};\n\npub trait Replace<T> {\n    fn replace(self, value: T) -> T;\n}\n\nimpl<'a, T> Replace<T> for &'a mut T {\n    fn replace(self, value: T) -> T {\n        mem::replace(self, value)\n    }\n}\n\nimpl<'a, T> Replace<T> for &'a Cell<T> {\n    fn replace(self, value: T) -> T {\n        self.replace(value)\n    }\n}\n\nimpl<'a, T> Replace<T> for &'a RefCell<T> {\n    fn replace(self, value: T) -> T {\n        let mut r = self.borrow_mut();\n        mem::replace(&mut *r, value)\n    }\n}\n\nuse core::ops::{Deref, DerefMut};\n\n#[macro_export]\nmacro_rules! take {\n    ($p: expr) => {\n        $crate::TakeHelper::new($p).take()\n    };\n    ($p: expr,) => {\n        $crate::take!($p)\n    };\n}\n\npub struct TakeHelper<T>(TakeHelper2<T>);\npub struct TakeHelper2<T>(TakeHelper3<T>);\npub struct TakeHelper3<T>(T);\n\nimpl<T> TakeHelper<T> {\n    pub fn new(inner: T) -> Self {\n        TakeHelper(TakeHelper2(TakeHelper3(inner)))\n    }\n}\n\nimpl<'a, T> TakeHelper<&'a mut T>\nwhere\n    T: Copy,\n{\n    pub fn take(&mut self) -> T {\n        *self.0 .0 .0\n    }\n}\n\nimpl<'a, T> TakeHelper<&'a Cell<T>>\nwhere\n    T: Copy,\n{\n    pub fn take(&mut self) -> T {\n        self.0 .0 .0.get()\n    }\n}\n\nimpl<'a, T> TakeHelper<&'a RefCell<T>>\nwhere\n    T: Copy,\n{\n    pub fn take(&mut self) -> T {\n        let r = self.0 .0 .0.borrow();\n        *r\n    }\n}\n\nimpl<T> Deref for TakeHelper<T> {\n    type Target = TakeHelper2<T>;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for TakeHelper<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<'a, T> TakeHelper2<&'a mut T>\nwhere\n    T: Default,\n{\n    pub fn take(&mut self) -> T {\n        mem::take(self.0 .0)\n    }\n}\n\nimpl<'a, T> TakeHelper2<&'a Cell<T>>\nwhere\n    T: Default,\n{\n    pub fn take(&mut self) -> T {\n        self.0 .0.take()\n    }\n}\n\nimpl<'a, T> TakeHelper2<&'a RefCell<T>>\nwhere\n    T: Default,\n{\n    pub fn take(&mut self) -> T {\n        let mut r = self.0 .0.borrow_mut();\n        mem::take(&mut *r)\n    }\n}\n\nimpl<T> Deref for TakeHelper2<T> {\n    type Target = TakeHelper3<T>;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for TakeHelper2<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<'a, T> TakeHelper3<&'a mut T>\nwhere\n    T: Clone,\n{\n    pub fn take(&mut self) -> T {\n        self.0.clone()\n    }\n}\n\nimpl<'a, T> TakeHelper3<&'a RefCell<T>>\nwhere\n    T: Clone,\n{\n    pub fn take(&mut self) -> T {\n        let r = self.0.borrow();\n        r.clone()\n    }\n}\n\n#[allow(unused)]\nfn rotated<T: Default + Clone>(grid: &Vec<Vec<T>>) -> Vec<Vec<T>> {\n    // 2次配列を左回りに90度回転したものを返す\n    let mut ret = nested_vec!(Default::default(); grid[0].len(); grid.len());\n    for i in 0..grid[0].len() {\n        for j in 0..grid.len() {\n            ret[i][j] = grid[grid.len() - 1 - j][i].clone();\n        }\n    }\n    return ret;\n}\n\n#[allow(unused)]\nfn shifted<T: Default + Clone>(grid: &Vec<Vec<T>>, dx: i64, dy: i64, default: T) -> Vec<Vec<T>> {\n    // 2次元配列を下に dx 右に dy 動かしたものを返す\n    let mut ret = nested_vec!(Default::default(); grid.len(); grid[0].len());\n    for i in 0..grid.len() {\n        for j in 0..grid[0].len() {\n            let mut value = default.clone();\n\n            let nx = i as i64 - dx;\n            let ny = j as i64 - dy;\n\n            if 0 <= nx && nx < grid.len() as i64 && 0 <= ny && ny < grid[0].len() as i64 {\n                value = grid[nx as usize][ny as usize].clone();\n            }\n\n            ret[i][j] = value;\n        }\n    }\n    return ret;\n}\n\n"

[template.new]
# `edition` for `Cargo.toml`.
edition = "2021"
# `profile` for `Cargo.toml`.
#
# By setting this, you can run tests with `opt-level=3` while enabling `debug-assertions` and `overflow-checks`.
#profile = '''
#[dev]
#opt-level = 3
#'''
dependencies = '''
# 202301から:
ac-library-rs = "=0.1.1"
once_cell = "=1.18.0"
static_assertions = "=1.1.0"
varisat = "=0.2.2"
memoise = "=0.3.2"
argio = "=0.2.0"
bitvec = "=1.0.1"
counter = "=0.5.7"
hashbag = "=0.1.11"
pathfinding = "=4.3.0"
recur-fn = "=2.2.0"
indexing = { version = "=0.4.1", features = ["experimental_pointer_ranges"] }
amplify = { version = "=3.14.2", features = ["c_raw", "rand", "stringly_conversions"] }
amplify_derive = "=2.11.3"
amplify_num = { version = "=0.4.1", features = ["std"] }
easy-ext = "=1.0.1"
multimap = "=0.9.0"
btreemultimap = "=0.1.1"
bstr = "=1.6.0"
az = "=1.2.1"
glidesort = "=0.1.2"
tap = "=1.0.1"
omniswap = "=0.1.0"
multiversion = "=0.7.2"
# 202004から続投:
num = "=0.4.1"
num-bigint = "=0.4.3"
num-complex = "=0.4.3"
num-integer = "=0.1.45"
num-iter = "=0.1.43"
num-rational = "=0.4.1"
num-traits = "=0.2.15"
num-derive = "=0.4.0"
ndarray = "=0.15.6"
nalgebra = "=0.32.3"
alga = "=0.9.3"
libm = "=0.2.7"
rand = { version = "=0.8.5", features = ["small_rng", "min_const_gen"] }
getrandom = "=0.2.10"
rand_chacha = "=0.3.1"
rand_core = "=0.6.4"
rand_hc = "=0.3.2"
rand_pcg = "=0.3.1"
rand_distr = "=0.4.3"
petgraph = "=0.6.3"
indexmap = "=2.0.0"
regex = "=1.9.1"
lazy_static = "=1.4.0"
ordered-float = "=3.7.0"
ascii = "=1.1.0"
permutohedron = "=0.2.4"
superslice = "=1.0.0"
itertools = "=0.11.0"
itertools-num = "=0.1.3"
maplit = "=1.0.2"
either = "=1.8.1"
im-rc = "=15.1.0"
fixedbitset = "=0.4.2"
bitset-fixed = "=0.1.0"
proconio = { version = "=0.4.5", features = ["derive"] }
text_io = "=0.1.12"
rustc-hash = "=1.1.0"
smallvec = { version = "=1.11.0", features = ["const_generics", "const_new", "write", "union", "serde", "arbitrary"] }

'''
dev-dependencies = '''
#atcoder-202004-lock = { git = "https://github.com/qryxip/atcoder-202004-lock" }
'''

[template.new.copy-files]
"./template-cargo-lock.toml" = "Cargo.lock"

[new]
platform = "atcoder"
kind = "oj-api"
url = "https://kenkoooo.com/atcoder/#/contest/show/{{ id }}"
path = "./{{ contest }}"


#[new]
#kind = "oj-api"
#url = "https://atcoder.jp/contests/{{ id }}"
#path = "./{{ contest }}"

# for Library-Checker
#[add]
#url = "https://judge.yosupo.jp/problem/{{ args[0] }}"
##is-contest = ["false"] # optional
##target-kind = "bin" # ["bin", "example"]. default to "bin"
#bin-name = '{{ args[0] }}'
##bin-alias = '{{ args[0] }}' # optional
##bin-src-path = './src/bin/{{ bin_alias }}.rs' # optional

# for yukicoder
#[add]
#url = '{% case args[0] %}{% when "contest" %}https://yukicoder.me/contests/{{ args[1] }}{% when "problem" %}https://yukicoder.me/problems/no/{{ args[1] }}{% endcase %}'
#is-contest = ["bash", "-c", '[[ $(cut -d / -f 4) == "contests" ]]'] # optional
##target-kind = "bin" # ["bin", "example"]. default to "bin"
#bin-name = '{% assign segments = url | split: "/" %}{{ segments[5] }}'
##bin-alias = '{% assign segments = url | split: "/" %}{{ segments[5] }}' # optional
##bin-src-path = './src/bin/{{ bin_alias }}.rs' # optional

[test]
# Toolchain for the test. (optional)
toolchain = "1.70.0"
# Profile for `cargo build`. ("dev" | "release")
#
# Defaults to `"dev"`.
#profile = "dev"

[submit]
kind = "file"
path = "{{ src_path }}"
language_id = "5054"
#[submit]
#kind = "command"
#args = ["cargo", "equip", "--exclude-atcoder-crates", "--resolve-cfgs", "--remove", "docs", "--minify", "libs", "--rustfmt", "--check", "--bin", "{{ bin_name }}"]
#language_id = "4050"
